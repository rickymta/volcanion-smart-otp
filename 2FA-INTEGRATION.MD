# H∆∞·ªõng D·∫´n T√≠ch H·ª£p 2FA v·ªõi SmartOTP

## üìã T·ªïng Quan

T√†i li·ªáu n√†y h∆∞·ªõng d·∫´n chi ti·∫øt c√°ch t√≠ch h·ª£p x√°c th·ª±c hai y·∫øu t·ªë (2FA - Two-Factor Authentication) t·ª´ h·ªá th·ªëng SmartOTP v√†o ·ª©ng d·ª•ng/h·ªá th·ªëng c·ªßa b·∫°n.

SmartOTP cung c·∫•p gi·∫£i ph√°p 2FA ho√†n ch·ªânh t∆∞∆°ng t·ª± nh∆∞ Google Authenticator v√† Microsoft Authenticator, h·ªó tr·ª£ c·∫£ TOTP (Time-based) v√† HOTP (Counter-based) theo ti√™u chu·∫©n RFC 6238 v√† RFC 4226.

## üèóÔ∏è Ki·∫øn Tr√∫c T·ªïng Quan

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     H·ªÜ TH·ªêNG C·ª¶A B·∫†N                            ‚îÇ
‚îÇ  (·ª®ng d·ª•ng Web/Mobile/Desktop c·∫ßn t√≠ch h·ª£p 2FA)                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì HTTP/HTTPS
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ   API Gateway      ‚îÇ
                  ‚îÇ   (Optional)       ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     SMARTOTP API                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ  ‚îÇ Auth API     ‚îÇ OTP API      ‚îÇ Accounts API ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ              ‚îÇ              ‚îÇ              ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ /register    ‚îÇ /generate    ‚îÇ /create      ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ /login       ‚îÇ /verify      ‚îÇ /list        ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ /refresh     ‚îÇ              ‚îÇ /delete      ‚îÇ                ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
‚îÇ  ‚îÇ         Business Logic Layer                 ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - CQRS Commands & Queries                   ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - MediatR Handlers                          ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - FluentValidation                          ‚îÇ              ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
‚îÇ  ‚îÇ           Security Services                  ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - OTP Generator (TOTP/HOTP)                 ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - AES-256 Encryption                        ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - JWT Authentication                        ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - Rate Limiting (Redis)                     ‚îÇ              ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ  PostgreSQL + Redis          ‚îÇ
            ‚îÇ  (Data + Cache)              ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üîÑ Lu·ªìng Ho·∫°t ƒê·ªông 2FA

### Lu·ªìng 1: ƒêƒÉng K√Ω v√† K√≠ch Ho·∫°t 2FA

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User    ‚îÇ                ‚îÇ  Your App    ‚îÇ              ‚îÇ SmartOTP   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ 1. ƒêƒÉng k√Ω t√†i kho·∫£n        ‚îÇ                            ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ 2. T·∫°o user trong SmartOTP ‚îÇ
     ‚îÇ                             ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ 3. JWT tokens + User Info  ‚îÇ
     ‚îÇ                             ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ 4. Y√™u c·∫ßu k√≠ch ho·∫°t 2FA    ‚îÇ                            ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ 5. T·∫°o OTP Account         ‚îÇ
     ‚îÇ                             ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ 6. Secret Key + QR Code    ‚îÇ
     ‚îÇ                             ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ                             ‚îÇ    Data (otpauth://)       ‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ 7. Hi·ªÉn th·ªã QR Code         ‚îÇ                            ‚îÇ
     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ 8. Qu√©t QR b·∫±ng app (GA)    ‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ 9. Nh·∫≠p m√£ OTP x√°c nh·∫≠n     ‚îÇ                            ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ 10. Verify OTP             ‚îÇ
     ‚îÇ                             ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ 11. {isValid: true}        ‚îÇ
     ‚îÇ                             ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ 12. K√≠ch ho·∫°t 2FA th√†nh c√¥ng‚îÇ                            ‚îÇ
     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                            ‚îÇ
```

### Lu·ªìng 2: ƒêƒÉng Nh·∫≠p v·ªõi 2FA

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User    ‚îÇ                ‚îÇ  Your App    ‚îÇ              ‚îÇ SmartOTP   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ 1. Nh·∫≠p email/password      ‚îÇ                            ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ 2. Login request           ‚îÇ
     ‚îÇ                             ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ 3. JWT tokens (ho·∫∑c error) ‚îÇ
     ‚îÇ                             ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ 4. Ki·ªÉm tra 2FA enabled    ‚îÇ
     ‚îÇ                             ‚îÇ    (trong DB c·ªßa b·∫°n)      ‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ 5. Y√™u c·∫ßu nh·∫≠p OTP         ‚îÇ                            ‚îÇ
     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ 6. Nh·∫≠p m√£ OTP t·ª´ app       ‚îÇ                            ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ 7. Verify OTP              ‚îÇ
     ‚îÇ                             ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ 8. {isValid: true/false}   ‚îÇ
     ‚îÇ                             ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ 9. ƒêƒÉng nh·∫≠p th√†nh c√¥ng     ‚îÇ                            ‚îÇ
     ‚îÇ    ho·∫∑c th·∫•t b·∫°i            ‚îÇ                            ‚îÇ
     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                            ‚îÇ
```

### Lu·ªìng 3: X√°c Th·ª±c Giao D·ªãch Quan Tr·ªçng

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  User    ‚îÇ                ‚îÇ  Your App    ‚îÇ              ‚îÇ SmartOTP   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ 1. Th·ª±c hi·ªán giao d·ªãch      ‚îÇ                            ‚îÇ
     ‚îÇ    quan tr·ªçng               ‚îÇ                            ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ 2. Y√™u c·∫ßu x√°c nh·∫≠n OTP     ‚îÇ                            ‚îÇ
     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ 3. Nh·∫≠p m√£ OTP              ‚îÇ                            ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ 4. Verify OTP              ‚îÇ
     ‚îÇ                             ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ 5. {isValid: true/false}   ‚îÇ
     ‚îÇ                             ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ                             ‚îÇ 6. Th·ª±c hi·ªán giao d·ªãch     ‚îÇ
     ‚îÇ                             ‚îÇ    n·∫øu OTP h·ª£p l·ªá          ‚îÇ
     ‚îÇ                             ‚îÇ                            ‚îÇ
     ‚îÇ 7. K·∫øt qu·∫£ giao d·ªãch        ‚îÇ                            ‚îÇ
     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                            ‚îÇ
```

## üîê Chi Ti·∫øt API Endpoints

### 1. ƒêƒÉng K√Ω User trong SmartOTP

**Endpoint:** `POST /api/auth/register`

**Headers:**
```
Content-Type: application/json
```

**Request Body:**
```json
{
  "email": "user@example.com",
  "password": "SecurePassword123!",
  "firstName": "John",
  "lastName": "Doe"
}
```

**Response:** `200 OK`
```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refreshToken": "base64_encoded_refresh_token",
  "accessTokenExpiresAt": "2025-11-21T13:00:00Z",
  "refreshTokenExpiresAt": "2025-11-28T12:00:00Z",
  "user": {
    "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
    "email": "user@example.com",
    "firstName": "John",
    "lastName": "Doe",
    "isEmailVerified": false,
    "createdAt": "2025-11-21T12:00:00Z"
  }
}
```

### 2. ƒêƒÉng Nh·∫≠p

**Endpoint:** `POST /api/auth/login`

**Headers:**
```
Content-Type: application/json
```

**Request Body:**
```json
{
  "email": "user@example.com",
  "password": "SecurePassword123!"
}
```

**Response:** `200 OK` (Same as register)

### 3. Refresh Token

**Endpoint:** `POST /api/auth/refresh-token`

**Headers:**
```
Content-Type: application/json
```

**Request Body:**
```json
{
  "refreshToken": "your_refresh_token_here"
}
```

**Response:** `200 OK` (New tokens)

### 4. T·∫°o OTP Account (K√≠ch Ho·∫°t 2FA)

**Endpoint:** `POST /api/otpaccounts`

**Headers:**
```
Content-Type: application/json
Authorization: Bearer {accessToken}
```

**Request Body (TOTP - Time-based):**
```json
{
  "issuer": "YourAppName",
  "accountName": "user@example.com",
  "type": "TOTP",
  "algorithm": "SHA1",
  "digits": 6,
  "period": 30
}
```

**Request Body (HOTP - Counter-based):**
```json
{
  "issuer": "YourAppName",
  "accountName": "user@example.com",
  "type": "HOTP",
  "algorithm": "SHA1",
  "digits": 6,
  "counter": 0
}
```

**Response:** `201 Created`
```json
{
  "id": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
  "issuer": "YourAppName",
  "accountName": "user@example.com",
  "type": "TOTP",
  "algorithm": "SHA1",
  "digits": 6,
  "period": 30,
  "counter": 0,
  "sortOrder": 0,
  "createdAt": "2025-11-21T12:00:00Z"
}
```

**L∆∞u √Ω:** Sau khi t·∫°o OTP account, b·∫°n c·∫ßn t·∫°o QR code ƒë·ªÉ user qu√©t. Format:
```
otpauth://totp/YourAppName:user@example.com?secret=BASE32SECRET&issuer=YourAppName&algorithm=SHA1&digits=6&period=30
```

### 5. L·∫•y Danh S√°ch OTP Accounts

**Endpoint:** `GET /api/otpaccounts`

**Headers:**
```
Authorization: Bearer {accessToken}
```

**Response:** `200 OK`
```json
[
  {
    "id": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
    "issuer": "YourAppName",
    "accountName": "user@example.com",
    "type": "TOTP",
    "algorithm": "SHA1",
    "digits": 6,
    "period": 30,
    "counter": 0,
    "sortOrder": 0,
    "createdAt": "2025-11-21T12:00:00Z"
  }
]
```

### 6. Generate OTP Code (D√πng cho Backend Testing)

**Endpoint:** `GET /api/otp/generate/{accountId}`

**Headers:**
```
Authorization: Bearer {accessToken}
```

**Response:** `200 OK`
```json
{
  "code": "123456",
  "remainingSeconds": 25,
  "generatedAt": "2025-11-21T12:00:00Z"
}
```

**L∆∞u √Ω:** Endpoint n√†y ch·ªâ d√πng cho testing. Trong production, user s·∫Ω l·∫•y m√£ t·ª´ Google Authenticator ho·∫∑c app t∆∞∆°ng t·ª±.

### 7. Verify OTP Code (Quan Tr·ªçng Nh·∫•t)

**Endpoint:** `POST /api/otp/verify`

**Headers:**
```
Content-Type: application/json
Authorization: Bearer {accessToken}
```

**Request Body:**
```json
{
  "accountId": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
  "code": "123456"
}
```

**Response:** `200 OK`
```json
{
  "isValid": true
}
```

**Rate Limiting:**
- T·ªëi ƒëa 5 l·∫ßn th·ª≠ trong 5 ph√∫t
- Sau 5 l·∫ßn th·∫•t b·∫°i, ph·∫£i ƒë·ª£i 5 ph√∫t

**Error Response:** `400 Bad Request`
```json
{
  "message": "Too many verification attempts. Please try again later."
}
```

### 8. X√≥a OTP Account (T·∫Øt 2FA)

**Endpoint:** `DELETE /api/otpaccounts/{accountId}`

**Headers:**
```
Authorization: Bearer {accessToken}
```

**Response:** `204 No Content`

## üíª V√≠ D·ª• Code T√≠ch H·ª£p

### 1. T√≠ch H·ª£p v·ªõi ASP.NET Core

```csharp
// Services/SmartOtpService.cs
public class SmartOtpService : ISmartOtpService
{
    private readonly HttpClient _httpClient;
    private readonly IConfiguration _configuration;
    
    public SmartOtpService(HttpClient httpClient, IConfiguration configuration)
    {
        _httpClient = httpClient;
        _configuration = configuration;
        _httpClient.BaseAddress = new Uri(_configuration["SmartOtp:ApiUrl"]);
    }
    
    // T·∫°o OTP Account cho user
    public async Task<OtpAccountDto> EnableTwoFactorAsync(string accessToken, string email)
    {
        _httpClient.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", accessToken);
            
        var request = new
        {
            issuer = "YourAppName",
            accountName = email,
            type = "TOTP",
            algorithm = "SHA1",
            digits = 6,
            period = 30
        };
        
        var response = await _httpClient.PostAsJsonAsync("/api/otpaccounts", request);
        response.EnsureSuccessStatusCode();
        
        return await response.Content.ReadFromJsonAsync<OtpAccountDto>();
    }
    
    // Verify OTP code
    public async Task<bool> VerifyOtpAsync(string accessToken, Guid accountId, string code)
    {
        _httpClient.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", accessToken);
            
        var request = new { accountId, code };
        
        var response = await _httpClient.PostAsJsonAsync("/api/otp/verify", request);
        
        if (!response.IsSuccessStatusCode)
        {
            return false;
        }
        
        var result = await response.Content.ReadFromJsonAsync<VerifyResult>();
        return result?.IsValid ?? false;
    }
    
    // Generate QR Code URL
    public string GenerateQrCodeUrl(string secret, string issuer, string accountName)
    {
        var otpAuthUrl = $"otpauth://totp/{Uri.EscapeDataString(issuer)}:{Uri.EscapeDataString(accountName)}" +
                        $"?secret={secret}" +
                        $"&issuer={Uri.EscapeDataString(issuer)}" +
                        $"&algorithm=SHA1&digits=6&period=30";
        
        // S·ª≠ d·ª•ng service nh∆∞ QRCoder ho·∫∑c API nh∆∞ api.qrserver.com
        return $"https://api.qrserver.com/v1/create-qr-code/?size=300x300&data={Uri.EscapeDataString(otpAuthUrl)}";
    }
}

// Controllers/AccountController.cs
[ApiController]
[Route("api/[controller]")]
public class AccountController : ControllerBase
{
    private readonly ISmartOtpService _otpService;
    
    [HttpPost("enable-2fa")]
    [Authorize]
    public async Task<IActionResult> EnableTwoFactor()
    {
        var email = User.FindFirst(ClaimTypes.Email)?.Value;
        var accessToken = Request.Headers["Authorization"].ToString().Replace("Bearer ", "");
        
        // T·∫°o OTP account trong SmartOTP
        var otpAccount = await _otpService.EnableTwoFactorAsync(accessToken, email);
        
        // L∆∞u accountId v√†o database c·ªßa b·∫°n
        await SaveUserOtpAccountId(User.GetUserId(), otpAccount.Id);
        
        // T·∫°o QR code URL (secret ƒë∆∞·ª£c tr·∫£ v·ªÅ t·ª´ SmartOTP - c·∫ßn th√™m v√†o response)
        var qrCodeUrl = _otpService.GenerateQrCodeUrl(
            otpAccount.Secret, // C·∫ßn th√™m field n√†y v√†o response
            otpAccount.Issuer,
            otpAccount.AccountName
        );
        
        return Ok(new { otpAccount, qrCodeUrl });
    }
    
    [HttpPost("verify-2fa")]
    [Authorize]
    public async Task<IActionResult> VerifyTwoFactor([FromBody] VerifyRequest request)
    {
        var accessToken = Request.Headers["Authorization"].ToString().Replace("Bearer ", "");
        var otpAccountId = await GetUserOtpAccountId(User.GetUserId());
        
        var isValid = await _otpService.VerifyOtpAsync(accessToken, otpAccountId, request.Code);
        
        if (!isValid)
        {
            return Unauthorized(new { message = "Invalid OTP code" });
        }
        
        return Ok(new { message = "2FA verification successful" });
    }
}
```

### 2. T√≠ch H·ª£p v·ªõi Node.js/Express

```javascript
// services/smartOtpService.js
const axios = require('axios');

class SmartOtpService {
  constructor() {
    this.apiUrl = process.env.SMARTOTP_API_URL || 'http://localhost:5000';
    this.client = axios.create({
      baseURL: this.apiUrl,
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }
  
  // ƒêƒÉng k√Ω user trong SmartOTP
  async registerUser(email, password, firstName, lastName) {
    const response = await this.client.post('/api/auth/register', {
      email,
      password,
      firstName,
      lastName
    });
    return response.data;
  }
  
  // Login
  async login(email, password) {
    const response = await this.client.post('/api/auth/login', {
      email,
      password
    });
    return response.data;
  }
  
  // K√≠ch ho·∫°t 2FA
  async enableTwoFactor(accessToken, email) {
    const response = await this.client.post('/api/otpaccounts', {
      issuer: 'YourAppName',
      accountName: email,
      type: 'TOTP',
      algorithm: 'SHA1',
      digits: 6,
      period: 30
    }, {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });
    return response.data;
  }
  
  // Verify OTP
  async verifyOtp(accessToken, accountId, code) {
    try {
      const response = await this.client.post('/api/otp/verify', {
        accountId,
        code
      }, {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      });
      return response.data.isValid;
    } catch (error) {
      if (error.response?.status === 400) {
        throw new Error(error.response.data.message);
      }
      throw error;
    }
  }
  
  // Generate QR Code URL
  generateQrCodeUrl(secret, issuer, accountName) {
    const otpAuthUrl = `otpauth://totp/${encodeURIComponent(issuer)}:${encodeURIComponent(accountName)}` +
                      `?secret=${secret}` +
                      `&issuer=${encodeURIComponent(issuer)}` +
                      `&algorithm=SHA1&digits=6&period=30`;
    
    return `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodeURIComponent(otpAuthUrl)}`;
  }
}

module.exports = new SmartOtpService();

// routes/auth.js
const express = require('express');
const router = express.Router();
const smartOtpService = require('../services/smartOtpService');
const authMiddleware = require('../middleware/auth');

// K√≠ch ho·∫°t 2FA
router.post('/enable-2fa', authMiddleware, async (req, res) => {
  try {
    const { email } = req.user;
    const accessToken = req.headers.authorization.replace('Bearer ', '');
    
    // T·∫°o OTP account
    const otpAccount = await smartOtpService.enableTwoFactor(accessToken, email);
    
    // L∆∞u accountId v√†o database
    await saveUserOtpAccountId(req.user.id, otpAccount.id);
    
    // T·∫°o QR code URL
    const qrCodeUrl = smartOtpService.generateQrCodeUrl(
      otpAccount.secret, // C·∫ßn th√™m v√†o response
      otpAccount.issuer,
      otpAccount.accountName
    );
    
    res.json({ otpAccount, qrCodeUrl });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Verify 2FA
router.post('/verify-2fa', authMiddleware, async (req, res) => {
  try {
    const { code } = req.body;
    const accessToken = req.headers.authorization.replace('Bearer ', '');
    const otpAccountId = await getUserOtpAccountId(req.user.id);
    
    const isValid = await smartOtpService.verifyOtp(accessToken, otpAccountId, code);
    
    if (!isValid) {
      return res.status(401).json({ message: 'Invalid OTP code' });
    }
    
    res.json({ message: '2FA verification successful' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

module.exports = router;
```

### 3. T√≠ch H·ª£p v·ªõi Python/FastAPI

```python
# services/smart_otp_service.py
import httpx
from typing import Optional
from urllib.parse import quote

class SmartOtpService:
    def __init__(self, api_url: str):
        self.api_url = api_url
        self.client = httpx.AsyncClient(base_url=api_url)
    
    async def register_user(self, email: str, password: str, 
                          first_name: str, last_name: str) -> dict:
        response = await self.client.post('/api/auth/register', json={
            'email': email,
            'password': password,
            'firstName': first_name,
            'lastName': last_name
        })
        response.raise_for_status()
        return response.json()
    
    async def login(self, email: str, password: str) -> dict:
        response = await self.client.post('/api/auth/login', json={
            'email': email,
            'password': password
        })
        response.raise_for_status()
        return response.json()
    
    async def enable_two_factor(self, access_token: str, email: str) -> dict:
        response = await self.client.post('/api/otpaccounts', 
            json={
                'issuer': 'YourAppName',
                'accountName': email,
                'type': 'TOTP',
                'algorithm': 'SHA1',
                'digits': 6,
                'period': 30
            },
            headers={'Authorization': f'Bearer {access_token}'}
        )
        response.raise_for_status()
        return response.json()
    
    async def verify_otp(self, access_token: str, 
                        account_id: str, code: str) -> bool:
        try:
            response = await self.client.post('/api/otp/verify',
                json={'accountId': account_id, 'code': code},
                headers={'Authorization': f'Bearer {access_token}'}
            )
            response.raise_for_status()
            result = response.json()
            return result.get('isValid', False)
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 400:
                raise ValueError(e.response.json().get('message'))
            raise
    
    def generate_qr_code_url(self, secret: str, issuer: str, 
                            account_name: str) -> str:
        otpauth_url = (
            f"otpauth://totp/{quote(issuer)}:{quote(account_name)}"
            f"?secret={secret}"
            f"&issuer={quote(issuer)}"
            f"&algorithm=SHA1&digits=6&period=30"
        )
        return f"https://api.qrserver.com/v1/create-qr-code/?size=300x300&data={quote(otpauth_url)}"

# routers/auth.py
from fastapi import APIRouter, Depends, HTTPException, Header
from services.smart_otp_service import SmartOtpService

router = APIRouter()
otp_service = SmartOtpService(api_url="http://localhost:5000")

@router.post("/enable-2fa")
async def enable_two_factor(
    authorization: str = Header(...)
):
    try:
        access_token = authorization.replace("Bearer ", "")
        # Get user email from your auth system
        email = get_current_user_email(access_token)
        
        # Create OTP account
        otp_account = await otp_service.enable_two_factor(access_token, email)
        
        # Save account ID to your database
        await save_user_otp_account_id(user_id, otp_account['id'])
        
        # Generate QR code URL
        qr_code_url = otp_service.generate_qr_code_url(
            otp_account['secret'],  # Need to add this field to response
            otp_account['issuer'],
            otp_account['accountName']
        )
        
        return {
            'otpAccount': otp_account,
            'qrCodeUrl': qr_code_url
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/verify-2fa")
async def verify_two_factor(
    code: str,
    authorization: str = Header(...)
):
    try:
        access_token = authorization.replace("Bearer ", "")
        # Get user OTP account ID from your database
        otp_account_id = await get_user_otp_account_id(user_id)
        
        is_valid = await otp_service.verify_otp(access_token, otp_account_id, code)
        
        if not is_valid:
            raise HTTPException(status_code=401, detail="Invalid OTP code")
        
        return {'message': '2FA verification successful'}
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

## üéØ C√°c Tr∆∞·ªùng H·ª£p S·ª≠ D·ª•ng Ph·ªï Bi·∫øn

### 1. ƒêƒÉng Nh·∫≠p v·ªõi 2FA B·∫Øt Bu·ªôc

```
1. User nh·∫≠p email/password
2. H·ªá th·ªëng x√°c th·ª±c th√¥ng tin ƒëƒÉng nh·∫≠p
3. Ki·ªÉm tra user c√≥ b·∫≠t 2FA kh√¥ng (trong DB c·ªßa b·∫°n)
4. N·∫øu c√≥:
   a. Y√™u c·∫ßu nh·∫≠p OTP code
   b. User nh·∫≠p code t·ª´ Google Authenticator
   c. G·ªçi SmartOTP API ƒë·ªÉ verify code
   d. N·∫øu h·ª£p l·ªá: T·∫°o session/token v√† cho ph√©p ƒëƒÉng nh·∫≠p
   e. N·∫øu kh√¥ng h·ª£p l·ªá: T·ª´ ch·ªëi v√† y√™u c·∫ßu nh·∫≠p l·∫°i
5. N·∫øu kh√¥ng c√≥ 2FA: ƒêƒÉng nh·∫≠p b√¨nh th∆∞·ªùng
```

### 2. 2FA T√πy Ch·ªçn (Optional)

```
1. User ƒëƒÉng nh·∫≠p th√†nh c√¥ng
2. Trong trang c√†i ƒë·∫∑t t√†i kho·∫£n, c√≥ option "Enable 2FA"
3. User click "Enable 2FA":
   a. G·ªçi SmartOTP API ƒë·ªÉ t·∫°o OTP account
   b. Hi·ªÉn th·ªã QR code cho user qu√©t
   c. Y√™u c·∫ßu user nh·∫≠p code ƒë·ªÉ x√°c nh·∫≠n ƒë√£ qu√©t th√†nh c√¥ng
   d. Verify code qua SmartOTP API
   e. N·∫øu h·ª£p l·ªá: L∆∞u tr·∫°ng th√°i 2FA enabled v√†o DB
4. L·∫ßn ƒëƒÉng nh·∫≠p ti·∫øp theo s·∫Ω y√™u c·∫ßu OTP
```

### 3. X√°c Th·ª±c Giao D·ªãch Quan Tr·ªçng

```
1. User th·ª±c hi·ªán giao d·ªãch nh·∫°y c·∫£m (chuy·ªÉn ti·ªÅn, ƒë·ªïi m·∫≠t kh·∫©u, etc.)
2. Hi·ªÉn th·ªã popup y√™u c·∫ßu nh·∫≠p OTP
3. User nh·∫≠p OTP code
4. Verify code qua SmartOTP API
5. N·∫øu h·ª£p l·ªá: Th·ª±c hi·ªán giao d·ªãch
6. N·∫øu kh√¥ng h·ª£p l·ªá: T·ª´ ch·ªëi v√† log l·∫°i
```

### 4. Step-up Authentication

```
1. User ƒë√£ ƒëƒÉng nh·∫≠p b√¨nh th∆∞·ªùng (kh√¥ng c√≥ 2FA)
2. Khi truy c·∫≠p t√≠nh nƒÉng nh·∫°y c·∫£m:
   a. Ki·ªÉm tra user c√≥ OTP account kh√¥ng
   b. N·∫øu c√≥: Y√™u c·∫ßu verify OTP tr∆∞·ªõc khi cho ph√©p
   c. N·∫øu kh√¥ng: Y√™u c·∫ßu enable 2FA tr∆∞·ªõc
```

## üì± ·ª®ng D·ª•ng Authenticator T∆∞∆°ng Th√≠ch

SmartOTP t∆∞∆°ng th√≠ch v·ªõi t·∫•t c·∫£ c√°c ·ª©ng d·ª•ng h·ªó tr·ª£ TOTP/HOTP theo chu·∫©n RFC:

- **Google Authenticator** (iOS/Android)
- **Microsoft Authenticator** (iOS/Android)
- **Authy** (iOS/Android/Desktop)
- **1Password** (c√≥ t√≠nh nƒÉng TOTP)
- **LastPass Authenticator**
- **FreeOTP** (Open source)
- **andOTP** (Android, open source)

## üîí Best Practices

### 1. B·∫£o M·∫≠t

- ‚úÖ **HTTPS Only**: Lu√¥n s·ª≠ d·ª•ng HTTPS khi giao ti·∫øp v·ªõi SmartOTP API
- ‚úÖ **L∆∞u tr·ªØ Token an to√†n**: Kh√¥ng l∆∞u access token ·ªü client-side l√¢u d√†i
- ‚úÖ **Rate Limiting**: SmartOTP ƒë√£ c√≥ rate limiting, nh∆∞ng n√™n implement th√™m ·ªü app c·ªßa b·∫°n
- ‚úÖ **Backup Codes**: Cung c·∫•p backup codes cho user khi m·∫•t ƒëi·ªán tho·∫°i
- ‚úÖ **Audit Log**: Log t·∫•t c·∫£ c√°c ho·∫°t ƒë·ªông 2FA (enable/disable/verify)

### 2. User Experience

- ‚úÖ **H∆∞·ªõng d·∫´n r√µ r√†ng**: Cung c·∫•p h∆∞·ªõng d·∫´n chi ti·∫øt c√°ch qu√©t QR code
- ‚úÖ **Hi·ªÉn th·ªã th·ªùi gian c√≤n l·∫°i**: Cho TOTP, hi·ªÉn th·ªã countdown
- ‚úÖ **Multiple devices**: Cho ph√©p user c√≥ nhi·ªÅu OTP account cho c√πng 1 t√†i kho·∫£n
- ‚úÖ **Recovery mechanism**: C√≥ ph∆∞∆°ng √°n kh√¥i ph·ª•c khi m·∫•t OTP device
- ‚úÖ **Clear error messages**: Th√¥ng b√°o l·ªói r√µ r√†ng khi verify fail

### 3. Database Schema

Trong database c·ªßa b·∫°n, n√™n c√≥ b·∫£ng l∆∞u th√¥ng tin:

```sql
CREATE TABLE user_two_factor (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id),
    smartotp_account_id UUID NOT NULL, -- ID t·ª´ SmartOTP
    is_enabled BOOLEAN DEFAULT false,
    enabled_at TIMESTAMP,
    backup_codes TEXT[], -- M√£ backup
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Index
CREATE INDEX idx_user_two_factor_user_id ON user_two_factor(user_id);
```

### 4. Error Handling

```csharp
public async Task<bool> VerifyOtpSafely(string accessToken, Guid accountId, string code)
{
    try
    {
        return await _otpService.VerifyOtpAsync(accessToken, accountId, code);
    }
    catch (HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.BadRequest)
    {
        // Rate limit ho·∫∑c invalid input
        _logger.LogWarning("OTP verification failed: {Message}", ex.Message);
        return false;
    }
    catch (HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.Unauthorized)
    {
        // Token h·∫øt h·∫°n, c·∫ßn refresh
        var newToken = await RefreshAccessToken();
        return await _otpService.VerifyOtpAsync(newToken, accountId, code);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error verifying OTP");
        throw;
    }
}
```

## üöÄ Tri·ªÉn Khai Production

### 1. Infrastructure

```yaml
# docker-compose.yml (Your App)
version: '3.8'
services:
  your-app:
    image: your-app:latest
    environment:
      - SMARTOTP_API_URL=https://smartotp.yourdomain.com
    depends_on:
      - smartotp
  
  smartotp:
    image: smartotp:latest
    environment:
      - ConnectionStrings__DefaultConnection=...
      - ConnectionStrings__Redis=...
      - Jwt__Secret=...
      - Encryption__Key=...
    ports:
      - "5000:5000"
```

### 2. Environment Variables

```bash
# .env
SMARTOTP_API_URL=https://smartotp.yourdomain.com
SMARTOTP_TIMEOUT_SECONDS=30
```

### 3. Health Check

```csharp
public async Task<bool> CheckSmartOtpHealth()
{
    try
    {
        var response = await _httpClient.GetAsync("/health");
        return response.IsSuccessStatusCode;
    }
    catch
    {
        return false;
    }
}
```

### 4. Monitoring

Theo d√µi c√°c metrics:
- S·ªë l∆∞·ª£ng verify requests
- T·ª∑ l·ªá verify th√†nh c√¥ng/th·∫•t b·∫°i
- Response time c·ªßa SmartOTP API
- S·ªë l∆∞·ª£ng rate limit hits

## üìû Troubleshooting

### L·ªói Th∆∞·ªùng G·∫∑p

#### 1. "Too many verification attempts"
**Nguy√™n nh√¢n:** User ƒë√£ th·ª≠ sai OTP qu√° 5 l·∫ßn trong 5 ph√∫t
**Gi·∫£i ph√°p:** ƒê·ª£i 5 ph√∫t ho·∫∑c clear cache Redis

#### 2. "OTP account not found"
**Nguy√™n nh√¢n:** AccountId kh√¥ng t·ªìn t·∫°i ho·∫∑c kh√¥ng thu·ªôc user hi·ªán t·∫°i
**Gi·∫£i ph√°p:** Ki·ªÉm tra l·∫°i accountId trong database

#### 3. "Invalid OTP code"
**Nguy√™n nh√¢n:** 
- Code ƒë√£ h·∫øt h·∫°n (TOTP)
- Clock skew gi·ªØa server v√† device
- User nh·∫≠p sai code

**Gi·∫£i ph√°p:**
- ƒê·∫£m b·∫£o server time ƒë·ªìng b·ªô (NTP)
- TOTP c√≥ window = 1 (cho ph√©p ¬±30s)
- Y√™u c·∫ßu user nh·∫≠p l·∫°i

#### 4. "Unauthorized"
**Nguy√™n nh√¢n:** JWT token h·∫øt h·∫°n
**Gi·∫£i ph√°p:** Refresh token v√† th·ª≠ l·∫°i

## üìä Sequence Diagram ƒê·∫ßy ƒê·ªß

```mermaid
sequenceDiagram
    participant U as User
    participant A as Your App
    participant S as SmartOTP API
    participant D as Database
    participant R as Redis
    
    Note over U,R: Setup 2FA Flow
    U->>A: Enable 2FA
    A->>S: POST /api/otpaccounts (with JWT)
    S->>D: Create OTP Account
    S->>D: Encrypt & Store Secret
    D-->>S: Account Created
    S-->>A: Account Info + Secret
    A->>A: Generate QR Code
    A-->>U: Display QR Code
    U->>U: Scan with Google Auth
    U->>A: Submit verification code
    A->>S: POST /api/otp/verify
    S->>D: Get OTP Account
    S->>S: Decrypt Secret
    S->>S: Verify TOTP Code
    S-->>A: {isValid: true}
    A->>D: Save 2FA enabled flag
    A-->>U: 2FA Enabled Successfully
    
    Note over U,R: Login with 2FA Flow
    U->>A: Login (email/password)
    A->>A: Validate credentials
    A->>D: Check if 2FA enabled
    D-->>A: 2FA is enabled
    A-->>U: Request OTP Code
    U->>U: Check Google Auth
    U->>A: Submit OTP Code
    A->>S: POST /api/otp/verify
    S->>R: Check rate limit
    R-->>S: Attempts: 1/5
    S->>D: Get OTP Account
    S->>S: Decrypt Secret
    S->>S: Verify TOTP Code
    S->>D: Log audit event
    S-->>A: {isValid: true}
    A->>A: Create session
    A-->>U: Login successful
```

## üîó Resources

- **RFC 6238**: TOTP Specification - https://tools.ietf.org/html/rfc6238
- **RFC 4226**: HOTP Specification - https://tools.ietf.org/html/rfc4226
- **Google Authenticator**: https://support.google.com/accounts/answer/1066447
- **QR Code Generator**: https://goqr.me/api/
- **SmartOTP Repository**: [Your GitHub Repo]

## üìù K·∫øt Lu·∫≠n

SmartOTP cung c·∫•p gi·∫£i ph√°p 2FA ho√†n ch·ªânh, d·ªÖ t√≠ch h·ª£p v√† b·∫£o m·∫≠t cao. V·ªõi ki·∫øn tr√∫c Clean Architecture v√† DDD, h·ªá th·ªëng ƒë·∫£m b·∫£o:

- ‚úÖ Tu√¢n th·ªß chu·∫©n RFC 6238/4226
- ‚úÖ B·∫£o m·∫≠t v·ªõi AES-256 encryption
- ‚úÖ Rate limiting ƒë·ªÉ ch·ªëng brute force
- ‚úÖ Audit logging ƒë·∫ßy ƒë·ªß
- ‚úÖ D·ªÖ d√†ng scale v√† maintain

H√£y tu√¢n th·ªß c√°c best practices v√† th·ª±c hi·ªán testing k·ªπ l∆∞·ª°ng tr∆∞·ªõc khi deploy l√™n production.

## üìß Support

N·∫øu g·∫∑p v·∫•n ƒë·ªÅ khi t√≠ch h·ª£p, vui l√≤ng t·∫°o issue tr√™n GitHub ho·∫∑c li√™n h·ªá qua email.

---

**Version:** 1.0  
**Last Updated:** 2025-11-21  
**Author:** SmartOTP Team
